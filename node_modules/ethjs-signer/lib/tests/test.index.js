'use strict';

var sign = require('../index.js').sign; // eslint-disable-line
var recover = require('../index.js').recover;
var TestRPC = require('ethereumjs-testrpc'); // eslint-disable-line
var Eth = require('ethjs-query'); // eslint-disable-line
var EthTx = require('ethereumjs-tx'); // eslint-disable-line
var generate = require('ethjs-account').generate; // eslint-disable-line
var publicToAddress = require('ethjs-account').publicToAddress; // eslint-disable-line
var assert = require('chai').assert;
var stripHexPrefix = require('strip-hex-prefix');
var BN = require('bn.js');

describe('recover', function () {
  describe('construction', function () {
    it('should import normally', function () {
      assert.equal(typeof recover, 'function');
    });
  });

  describe('functionality', function () {
    it('should recover from signed tx string', function () {
      var testAccount = generate('sdkjfhskjhskhjsfkjhsf093j9sdjfpisjdfoisjdfisdfsfkjhsfkjhskjfhkshdf');
      var rawTx = {
        to: testAccount.address.toLowerCase(),
        nonce: '0x' + new BN(0).toString(16),
        gasPrice: '0x' + new BN(0).toString(16),
        gasLimit: '0x' + new BN(0).toString(16),
        value: '0x' + new BN(0).toString(16),
        data: '0'
      };
      var signedTx = sign(rawTx, testAccount.privateKey, true);
      var signedTxString = sign(rawTx, testAccount.privateKey);
      var publicKey = recover(signedTxString, new BN(signedTx[6].toString('hex'), 16).toNumber(10), signedTx[7], signedTx[8]);
      var address = publicToAddress(publicKey);
      assert.equal(address, testAccount.address);
    });

    it('should recover from signed tx buffer', function () {
      var testAccount = generate('sdkjfhskjhskhjsfkjhsf093j9sdjfpisjdfoisjdfisdfsfkjhsfkjhskjfhkshdf');
      var rawTx = {
        to: testAccount.address.toLowerCase(),
        nonce: '0x' + new BN(0).toString(16),
        gasPrice: '0x' + new BN(0).toString(16),
        gasLimit: '0x' + new BN(0).toString(16),
        value: '0x' + new BN(0).toString(16),
        data: '0x'
      };
      var signedTx = sign(rawTx, testAccount.privateKey, true);
      var signedTxBuffer = new Buffer(stripHexPrefix(sign(rawTx, testAccount.privateKey)), 'hex');
      var publicKey = recover(signedTxBuffer, new BN(signedTx[6].toString('hex'), 16).toNumber(10), signedTx[7], signedTx[8]);
      var address = publicToAddress(publicKey);
      assert.equal(address, testAccount.address);
    });
  });
});

describe('sign', function () {
  describe('construction', function () {
    it('should import normally', function () {
      assert.equal(typeof sign, 'function');
    });
  });

  describe('functionality', function () {
    var account = generate('sdkjfhskjhskhjsfkjhsf093j9sdjfpisjdfoisjdfisdfsfkjhsfkjhskjfhkshdf');

    it('test gas shim', function () {
      assert.deepEqual(sign({ to: account.address, gas: 3000000 }, account.privateKey), sign({ to: account.address, gasLimit: 3000000 }, account.privateKey));
    });

    it('should sign a valid tx', function () {
      assert.equal(typeof sign({ to: account.address }, account.privateKey), 'string');
      assert.equal(typeof sign({ to: account.address }, account.privateKey, true), 'object');
    });

    it('should throw when invalid', function () {
      assert.throws(function () {
        return sign('');
      }, Error);
      assert.throws(function () {
        return sign({}, '');
      }, Error);
      assert.throws(function () {
        return sign({ to: account.address, gas: '0x89724982892748972349874239847987s29sdfhkjjsfh8823927482978923793248829724397' }, account.privateKey);
      }, Error);
      assert.throws(function () {
        return sign({ to: '0x00' }, account.privateKey);
      }, Error);
      assert.throws(function () {
        return sign({}, '0xfsd98');
      }, Error);
      assert.throws(function () {
        return sign({}, '0xkjdsfkjfsdkjs');
      }, Error);
      assert.throws(function () {
        return sign({}, 234879243);
      }, Error);
      assert.throws(function () {
        return sign({}, null);
      }, Error);
      assert.throws(function () {
        return sign(null, 243249);
      }, Error);
      // assert.throws(() => sign({}, account.privateKey), Error);
    });
  });

  describe('field testing against TestRPC', function () {
    it('should send a signed tx with testrpc provider', function (done) {
      var testAccount = generate('sdkjfhskjhskhjsfkjhsf093j9sdjfpisjdfoisjdfisdfsfkjhsfkjhskjfhkshdf');
      var provider = TestRPC.provider({
        accounts: [{
          address: testAccount.address,
          secretKey: testAccount.privateKey,
          balance: 999999999
        }]
      });
      var eth = new Eth(provider);
      var rawTx = {
        to: '0x6023E44829921590b24f458c9eE4F544507d59B6',
        gas: 300000,
        value: new BN(450000)
      };
      var signedTx = sign(rawTx, testAccount.privateKey);
      eth.sendRawTransaction(signedTx, function (err, txHash) {
        assert.equal(err, null);
        assert.equal(typeof txHash, 'string');

        setTimeout(function () {
          eth.getTransactionByHash(txHash, function (rErr, transaction) {
            assert.equal(rErr, null);

            assert.equal(testAccount.address.toLowerCase(), transaction.from);
            assert.equal(rawTx.to.toLowerCase(), transaction.to);
            assert.deepEqual(rawTx.value.toString(10), transaction.value.toString(10));
            assert.deepEqual(new BN(rawTx.gas).toString(10), transaction.gas.toString(10));

            done();
          });
        }, 400);
      });
    });
  });

  describe('should work the same as ethereumjs-tx', function () {
    it('should pass a thousand random signing tests', function () {
      for (var i = 0; i < 1000; i++) {
        // eslint-disable-line
        var testAccount = generate('sdkjfhskjhskhjsfkjhsf093j9sdjfpisjdfoisjdfisdfsfkjhsfkjhskjfhkshdf');
        var rawTx = {
          to: testAccount.address.toLowerCase(),
          nonce: '0x' + new BN(0).toString(16),
          gasPrice: '0x' + new BN(0).toString(16),
          gasLimit: '0x' + new BN(0).toString(16),
          value: '0x' + new BN(0).toString(16),
          data: '0x'
        };
        var tx = new EthTx(rawTx);
        tx.sign(new Buffer(testAccount.privateKey.slice(2), 'hex'));

        var ethjsSigner = sign(rawTx, testAccount.privateKey);
        var ethereumjsTx = '0x' + tx.serialize().toString('hex');

        assert.equal(ethjsSigner, ethereumjsTx);
      }
    });
  });
});